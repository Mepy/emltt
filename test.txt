let nat : U 0 = W (x:Bool) if x then Unit else Void
let zero : nat = tree(false, \ x . exfalso x nat)
let succ : nat -> nat = \ n . tree(true, \ _ . n)
let plus : nat -> nat -> nat = 
    \ m . \ n . induct m at nat with
    | tree(a, s, h) => if a 
        then succ (h unit)
        else n
let plus : nat -> nat -> nat =
    \ m . induct m at nat -> nat with
    | tree(a, s, h) => if a 
        then \ n . succ (h unit n)
        else \ n . n
let one = succ zero
let plus_one = plus one

let unit_unique : U 0 = Pi(x:Unit) Id(Unit, x, unit)
let unit_unique_proof : unit_unique =
    \ x . singleton x at y.Id(Unit, y, unit) with
    | unit => refl unit