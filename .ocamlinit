module S = Emltt.Syntax
module N = Emltt.Work.Nbe
open S
open N

(* 
let expr = S.Lam S.Trivial
let typ = S.Pi (S.Unit, S.Unit)
let value = eval [] expr
let v_typ = eval [] typ
;;



let expr2 = S.Lam (S.Exfalso (S.Index 0, S.Void))
let typ2 = S.Pi (S.Void, S.Void)
let value = eval [] expr2
let v_typ = eval [] typ2;;

N.quote 0 (Normal{typ=v_typ; value});;
*)

(* (* wait for surface syntax, a bit ugly for core syntax *)
let true_neq_false_typ = S.Pi (S.Id(S.Bool, S.true, S.false), S.Void)
let true_neq_false_expr = 
  *)

let nat = S.W(S.Bool, S.If(S.Index 0, S.Type 0, S.Unit, S.Void))
let zero = S.Tree(S.False, (* fhd:Void. *) S.Exfalso(S.Index 0(* fhd *), nat))
let succ = S.Lam((* n:Nat .*) S.Tree(S.True, (* ():Unit. *) S.Index 1(* n *)))
let one = S.App(succ, zero)
let one_nf = normalize [] one nat

let plus_type = S.Pi(nat, S.Pi(nat, nat))
let plus = S.Lam((* m:Nat *)S.Lam((* n:Nat *) S.Ind(S.Index 1 (* m *), (* t. *) nat,  
  (* a s h.*) S.If(S.Index 2(* a *),  nat,
    (* a==True, succ, 应该调转一下顺序的 *)
    S.App(succ, S.App(S.Index 0 (* h *), S.Trivial)),
    (* S.App(succ, S.App(S.Index 0 (* h *), S.Trivial)) *)
    (* a==False, zero *)
    S.Index 3 (* n *)
    
  )  
)))

(* 
let nat_nat = S.Pi(nat, nat)
let plus = S.Lam((* m:Nat *) S.Ind(S.Index 0 (* m *), (* t. *) nat_nat,  
(* a s h.*) S.If(S.Index 2(* a *), nat,
  (* a==True, succ, 应该调转一下顺序的 *)
  S.Lam(S.App(succ, S.App(S.App(S.Index 1 (* h *), S.Trivial), S.Index 0))),
  (* S.App(succ, S.App(S.Index 0 (* h *), S.Trivial)) *)
  (* a==False, zero *)
  S.Lam(S.Index 0)(* \ n. n *)
)  
))
*)

let two = S.App(S.App(plus, one_nf), one_nf)


let qt size vv tt = quote size (Normal{typ=tt; value=vv})

let plus_zero = S.App(plus, zero)
let nat_nat = S.Pi(nat, nat)
let vv = eval [] plus_zero
let tt = eval [] nat_nat

let plus_one = S.App(plus, one_nf)
let nat_nat = S.Pi(nat, nat)
let vv = eval [] plus_one
let tt = eval [] nat_nat

let two = normalize [] (S.App(succ, S.App(succ, zero))) nat
let plus_two = S.App(plus, two)
let nat_nat = S.Pi(nat, nat)
let vv = eval [] plus_two
let tt = eval [] nat_nat

(* 
let size = 0 
let Pi(src, dst), func = tt, vv
let arg = mk_var src size
let normal = Normal {typ=eval_clos dst arg; value=eval_app func arg}
let size = 1
let Normal{typ; value} = normal

let W(a_typ, b_typ_clos), Tree(a, s) = typ, value
let b_typ = eval_clos b_typ_clos a
let b = mk_var b_typ size
let normal = Normal {typ=W(a_typ, b_typ_clos); value=eval_clos s b}
*)

let unit_unique = let open S in Pi(Unit, Id(Type 0, Index 0, Trivial))
let unit_unique_proof = let open S in Lam(Singleton(Index 0, Id(Unit, Index 0, Trivial), 
  Refl(Trivial)
))
let test = normalize [] unit_unique_proof unit_unique = unit_unique_proof